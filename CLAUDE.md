# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

envmgr is a Rust-based dotfiles and CLI environment manager that allows switching between different environment configurations (work, personal, etc.) with automatic integration management for tools like GitHub CLI, 1Password SSH Agent, and Tailscale.

## Development Commands

### Building
```bash
# Development build
cargo build

# Release build
cargo build --release

# Build specific package
cargo build -p envmgr
```

### Testing
```bash
# Run all tests
cargo test

# Run tests for a specific module
cargo test --lib environment::manager

# Run tests for a specific function
cargo test test_slugify

# Run integration tests
cargo test --test integration_tests
```

### Running
```bash
# Run in development
cargo run -- <command>

# Examples
cargo run -- list
cargo run -- add "New Environment"
cargo run -- switch work
```

### Linting and Formatting
```bash
# Check formatting
cargo fmt -- --check

# Format code
cargo fmt

# Run clippy
cargo clippy

# Run clippy with all features
cargo clippy --all-features
```

## Architecture Overview

### Core Data Flow

The system follows a layered architecture:

```
Fish Shell Hook (auto-triggered)
    ↓
CLI Command (main.rs)
    ↓
EnvironmentManager (orchestrator)
    ├─ State (persistence layer)
    ├─ Config (YAML loading)
    ├─ Integrations (plugin handlers)
    └─ File Linking (symlink management)
```

### Key Components

**EnvironmentManager** (`environment/manager.rs`)
- Central orchestrator that coordinates all operations
- Manages state loading/saving, integration invocation, and file linking
- Key methods: `use_environment()`, `switch_environment_by_key()`, `link_files()`

**State System** (`state.rs`)
- Single source of truth: `~/.local/state/envmgr/state.yaml`
- Tracks current environment, applied env vars, and managed symlinks
- Uses TOML serialization (despite .yaml extension)

**Environment Loading** (`environment/mod.rs`, `config/environment.rs`)
- Base environment at `~/.config/envmgr/base/`
- Specific environments at `~/.config/envmgr/environments/<key>/`
- Each has `config.yaml` and optional `files/` directory
- Specific environments overlay/override base environment

**Integration Plugin System** (`integrations/`)
- Handler-based pattern: each integration implements `on_switch_to()`
- Called during `switch_environment()` before file linking
- Three integrations: OnePassword SSH (`op_ssh`), GitHub CLI (`gh_cli`), Tailscale (`tailscale`)
- Integrations are optional in config; presence is checked with `Option<T>`

### Critical Workflows

**Environment Switching:**
1. Load current state from `~/.local/state/envmgr/state.yaml`
2. Update `state.current_env_key` to new environment
3. Invoke all enabled integrations' `on_switch_to()` handlers
4. Call `link_files()` to update symlinks
5. Persist updated state

**Environment Activation (use command):**
1. Load state and determine current environment
2. Load base environment config
3. If not on base, load and merge specific environment config
4. Compute delta: vars to add vs vars to remove
5. Emit Fish shell commands to stdout: `set -gx` / `set -e -g`
6. Update `state.applied_env_vars` with new state
7. Persist state

**File Linking:**
- Discovers files recursively in `<env>/files/` directories
- Creates symlinks from `~/<path>` → `~/.config/envmgr/<env>/files/<path>`
- Tracks managed files in state to enable cleanup
- Won't overwrite real files (only manages symlinks)

### Fish Shell Integration

The Fish hook is generated by `make_fish_hook()` in main.rs and creates an event handler:

```fish
function __envmgr_export_eval --on-event fish_prompt
    command envmgr use | source
end
```

This runs `envmgr use` at every prompt, which outputs Fish commands that are evaluated by `source`. The commands modify the current shell session's environment variables.

**Shell command generation** (`cli.rs`):
- `Shell::set_env_var_cmd()` generates `set -gx VAR 'value'`
- `Shell::unset_env_var_cmd()` generates `set -e -g VAR`
- `fish_quote()` safely escapes values for Fish shell

## Important Implementation Details

### Integration Plugins

When adding new integrations, follow this pattern:

1. Create struct in `integrations/<name>.rs` for config
2. Add config as `Option<YourConfig>` to `EnvironmentConfig`
3. Implement `on_switch_to(config: &YourConfig) -> EnvMgrResult<OnSwitchToPluginResult>`
4. Add handler invocation in `EnvironmentManager::switch_environment()`

Example: see `integrations/tailscale.rs` for process-based integration, `integrations/gh_cli.rs` for file-modification integration.

### Error Handling

All fallible operations return `EnvMgrResult<T>` where `EnvMgrError` is defined in `error.rs` using thiserror:

```rust
#[derive(thiserror::Error, Debug)]
pub enum EnvMgrError {
    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),
    // ... more variants
}
```

Use `?` operator throughout for error propagation.

### State Persistence

State is read before every operation and written after modifications:

```rust
let mut state = State::get_state()?;
// ... modify state
state.store_state()?;
```

State is stored at `~/.local/state/envmgr/state.yaml` using the `dirs` crate's `state_dir()`.

### Configuration File Structure

Environment configs use a flat structure:

```yaml
name: "Display Name"
env_vars:
  - key: VAR_NAME
    value: "value"
# Optional integrations (all are Option<T>):
gh_cli:
  hosts:
    - host: "github.com"
      user: "username"
op_ssh:
  keys:
    - vault: "VaultName"
      item: "ItemName"
      account: "account@example.com"
tailscale:
  tailnet: "tailnet.example.com"
```

### Adding New Commands

1. Create command handler in `commands/<name>.rs`
2. Add to `commands/mod.rs`
3. Add variant to `Command` enum in `cli.rs`
4. Add match arm in `main()` dispatcher

For interactive commands, use the `dialoguer` crate (already a dependency). See `commands/add.rs` for examples of:
- Input prompts with validation
- Confirm prompts
- Auto-suggested values
- Slugification of user input

### File Discovery

`discover_files_in_dir()` in `environment/mod.rs` recursively finds all files (not directories) in a path. It's used to build the file mapping for symlink creation.

### Workspace Structure

This is a Cargo workspace with one member (`envmgr`):
- Root `Cargo.toml` defines workspace dependencies
- `envmgr/Cargo.toml` references workspace dependencies with `.workspace = true`

When adding dependencies, add to root `[workspace.dependencies]` and reference in member package.

## Testing Strategy

Tests are co-located with implementation in module `#[cfg(test)]` blocks:
- `error.rs`: Error conversion tests
- `environment/mod.rs`: File discovery tests
- `commands/add.rs`: Slugify and validation tests
- `cli.rs`: Shell command generation and quoting tests

Integration tests are in `envmgr/tests/integration_tests.rs`.

## Platform Support

Currently Linux-only with Fish shell support. The codebase uses:
- `dirs` crate for XDG directory discovery
- Fish-specific shell command generation in `cli.rs`

To add shell support, implement the `Shell` enum variants and their `set_env_var_cmd()` / `unset_env_var_cmd()` methods.

## Security Considerations

- **SSH Agent Config**: 1Password integration writes `~/.config/1Password/ssh/agent.toml` - ensure proper file permissions
- **GitHub CLI**: Modifies `~/.config/gh/hosts.yml` in-place using YAML parsing (preserves existing structure)
- **Tailscale**: Executes `tailscale switch` subprocess - validates tailnet exists before switching
- **File Linking**: Only creates symlinks, never overwrites real files
- **Shell Quoting**: All environment variable values are properly escaped via `fish_quote()` before being emitted in shell commands

## Directory Conventions

- `~/.config/envmgr/`: Configuration root (XDG_CONFIG_HOME)
- `~/.local/state/envmgr/`: Runtime state (XDG_STATE_HOME)
- Base environment is special-cased at `~/.config/envmgr/base/`
- Named environments are in `~/.config/envmgr/environments/<key>/`
